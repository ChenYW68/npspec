{
    "collab_server" : "",
    "contents" : "\n#' @import aldodevel\n#' @import FNN\n#' @export\niterate_spec_semipar <- function(y, observed, embed_fac = 1.2, n_iter = 100, par_spec_fun = spec_AR1,\n                                 kern_parm = 10, n_avg = 30, precondmethod = \"fft\", m = 10,\n                                 silent = TRUE, ncondsim = 0){\n\n    # pass NNarray through \"...\"\n\n    if(identical(par_spec_fun,FALSE)){\n        do_parametric_filter <- FALSE\n    } else {\n        do_parametric_filter <- TRUE\n    }\n\n    # error for bad embedding factor value\n    if( embed_fac < 1 ){\n        stop(\"Embedding factor embed_fac cannot be less than 1\")\n    }\n\n    # create embedded lattice\n    nvec_obs <- dim(y)\n    nvec <- round( nvec_obs*embed_fac )\n    y_embed <- array(NA,nvec)\n    y_embed[1:nvec_obs[1],1:nvec_obs[2]] <- y\n    observed_embed <- array(FALSE,nvec)\n    observed_embed[1:nvec_obs[1],1:nvec_obs[2]] <- observed\n\n    if( precondmethod == \"Vecchia\"){\n        locsfull <- expand.grid( 1:nvec[1], 1:nvec[2] )\n        locs <- locsfull[observed_embed,]\n        NNarray <- aldodevel::findOrderedNN_kdtree(locs,m)\n        NNarray[m+1,] <- (m+1):1 # need to make sure first part goes in the right order\n    } else {\n        NNarray <- NULL\n    }\n\n    # get grid size and define kerenel\n    n <- prod(nvec)\n    kern <- sqexp_kern(kern_parm, nvec)\n\n    # impute with mean\n    y0 <- y_embed\n    y0[!observed_embed] <- mean(y, na.rm = TRUE)\n\n    # define likelihood function (written for AR1 filter)\n    likfun <- function(x){\n        expitx <- expit(x)/4\n        return(-whittle_lik(pgram,expitx,par_spec_fun))\n    }\n\n    # set an initial value for optimization\n    parm <- 1/8\n    logitpar <- logit(parm*4)\n\n    # loop over number of iterations\n    specs <- array(NA,c(nvec,n_iter))\n\n    for(k in 1:n_iter){\n\n        # periodogram\n        pgram <- 1/n*abs( fft(y0) )^2\n\n        # do the optimization\n        if(do_parametric_filter){\n            res <- optim(logitpar,likfun,method=\"Brent\",lower=-6,upper=6)\n            logitpar <- res$par         # update logit parameter\n            parm <- expit(logitpar)/4   # update parameter\n\n            # parametric approximation\n            param_spec <- par_spec_fun(parm,nvec)\n        } else {\n            param_spec <- array(1,nvec)\n        }\n\n        # smooth ratio of periodogram to parametric approximation\n        sm_pgram <- smooth_pgram(pgram/param_spec,kern)\n        # estimate is product of smoothed ratio and parametric spec\n        specs[,,k] <- sm_pgram*param_spec\n\n        # do a conditional simulation with the new spectrum\n        y0 <- condsim_spec(y = y0,spec = specs[,,k],obs = observed_embed, silent = silent, maxit = 500, precondmethod = precondmethod, NNarray = NNarray)\n    }\n\n    avg_spec <- apply( specs[,,(n_iter-n_avg+1):n_iter], c(1,2), mean )\n    if( ncondsim == 0 ){\n        return(avg_spec)\n    } else {\n        condsims <- array( NA, c( nvec, ncondsim ) )\n        for(j in 1:ncondsim ){\n            condsims[,,j] <- condsim_spec(y0,avg_spec,observed_embed,silent = silent, maxit = 500, precondmethod = precondmethod, NNarray = NNarray)\n        }\n        return(list(avg_spec=avg_spec,condsims = condsims))\n    }\n}\n\n\n#' @export\niterate_spec <- function(y, observed, embed_fac = 1.2, burn_iters = 100, par_spec_fun = spec_AR1,\n                                 kern_parm = 10, precond_method = \"fft\", m = 10,\n                                 silent = TRUE, max_iter = 200){\n\n    if(identical(par_spec_fun,FALSE)){\n        do_parametric_filter <- FALSE\n    } else {\n        do_parametric_filter <- TRUE\n    }\n\n    # error for bad embedding factor value\n    if( embed_fac < 1 ){\n        stop(\"Embedding factor embed_fac cannot be less than 1\")\n    }\n\n    # create embedded lattice\n    nvec_obs <- dim(y)\n    nvec <- round( nvec_obs*embed_fac )\n    y_embed <- array(NA,nvec)\n    y_embed[1:nvec_obs[1],1:nvec_obs[2]] <- y\n    observed_embed <- array(FALSE,nvec)\n    observed_embed[1:nvec_obs[1],1:nvec_obs[2]] <- observed\n\n    if( precond_method == \"Vecchia\"){\n        locsfull <- expand.grid( 1:nvec[1], 1:nvec[2] )\n        locs <- locsfull[observed_embed,]\n        NNarray <- aldodevel::findOrderedNN_kdtree(locs,m)\n        NNarray[m+1,] <- (m+1):1 # need to make sure first part goes in the right order\n    } else {\n        NNarray <- NULL\n    }\n\n    # get grid size and define kerenel\n    n <- prod(nvec)\n    kern <- sqexp_kern(kern_parm, nvec)\n\n    # impute with mean\n    y0 <- y_embed\n    y0[!observed_embed] <- mean(y, na.rm = TRUE)\n\n    # define likelihood function (written for AR1 filter)\n    likfun <- function(x){\n        expitx <- expit(x)/4\n        return(-whittle_lik(pgram,expitx,par_spec_fun))\n    }\n\n    # set an initial value for optimization\n    parm <- 1/8\n    logitpar <- logit(parm*4)\n\n    # loop over number of iterations\n    #specs <- array(NA,c(nvec,n_iter))\n\n    for(k in 1:burn_iters){\n        # periodogram\n        pgram <- 1/n*abs( fft(y0) )^2\n        # do the optimization\n        if(do_parametric_filter){\n            res <- optim(logitpar,likfun,method=\"Brent\",lower=-6,upper=6)\n            logitpar <- res$par         # update logit parameter\n            parm <- expit(logitpar)/4   # update parameter\n            # parametric approximation\n            param_spec <- par_spec_fun(parm,nvec)\n        } else {\n            param_spec <- array(1,nvec)\n        }\n        # smooth ratio of periodogram to parametric approximation\n        sm_pgram <- smooth_pgram(pgram/param_spec,kern)\n        # estimate is product of smoothed ratio and parametric spec\n        spec <- sm_pgram*param_spec\n        # do a conditional simulation with the new spectrum\n        y0 <- condsim_spec(y = y0, spec = spec, obs = observed_embed, silent = silent, maxit = 500, precondmethod = precond_method, NNarray = NNarray)\n    }\n\n    spec_old <- spec\n    tolval <- 0.05\n\n    for(k in 1:max_iter){\n        pgram <- 1/n*abs( fft(y0) )^2\n        # do the optimization\n        if(do_parametric_filter){\n            res <- optim(logitpar,likfun,method=\"Brent\",lower=-6,upper=6)\n            logitpar <- res$par         # update logit parameter\n            parm <- expit(logitpar)/4   # update parameter\n            # parametric approximation\n            param_spec <- par_spec_fun(parm,nvec)\n        } else {\n            param_spec <- array(1,nvec)\n        }\n        # smooth ratio of periodogram to parametric approximation\n        sm_pgram <- smooth_pgram(pgram/param_spec,kern)\n        # estimate is product of smoothed ratio and parametric spec\n        spec <- sm_pgram*param_spec\n        # update the spectrum estimate\n        spec_new <- (k-1)/k*spec_old + 1/k*spec\n        # compare difference to tolerance\n        spec_sd <- sqrt( smooth_pgram( spec_old^2, kern^2 ) )\n\n        criterion <- max( abs(spec_new - spec_old)/spec_sd )\n        if( k %% 10 == 0 ) cat(paste(\"Averaging Iteration\",k,\"Criterion =\",round(criterion,4),\"\\n\"))\n        if( criterion < tolval ){\n            break\n        }\n\n        spec_old <- spec_new\n        y0 <- condsim_spec(y = y0, spec = spec_new, obs = observed_embed, silent = silent, maxit = 500, precondmethod = precond_method, NNarray = NNarray)\n\n    }\n    avg_spec <- spec_new\n\n    # get estimate of the likelihood\n    cat(\"Computing estimate of likelihood \\n\")\n    locsfull <- as.matrix( expand.grid( 1:nvec[1], 1:nvec[2] ) )\n    locs <- locsfull[observed_embed,]\n    NNarray <- aldodevel::findOrderedNN_kdtree(locs,40)\n    covarray <- 1/prod(dim(avg_spec))*Re( fft( avg_spec, inverse = TRUE ) )\n    yvec <- y_embed[observed_embed]\n    loglik <- vecchiaLik(covarray,yvec,locs,NNarray)\n    \n    # get conditional expectation\n    condexp <- condexp_spec(y0,avg_spec,observed_embed, silent=silent,maxit=500,precondmethod = precond_method, NNarray = NNarray)\n    \n    # get conditional simulations\n    ncondsim <- 4\n    condsim_array <- array( NA, c(nvec_obs,ncondsim) )\n    for(j in 1:ncondsim){\n        cursim <- condsim_spec(y0,avg_spec,observed_embed,silent=silent,precondmethod=precond_method,NNarray=NNarray)\n        condsim_array[,,j] <- cursim[1:nvec_obs[1],1:nvec_obs[2]]\n    }\n    \n    return(list( spec = avg_spec, cov = covarray, loglik = loglik, condexp = condexp[1:nvec_obs[1],1:nvec_obs[2]], condsim = condsim_array) )\n}\n\n\n\niterate_spec_semipar_old <- function(y, observed, n_iter = 100, par_spec_fun = spec_AR1,\n                                 kern_parm = 10, n_avg = 30, n_intraclass = 40, precondmethod = \"fft\", ...){\n\n    # pass NNarray through \"...\"\n\n    if(identical(par_spec_fun,FALSE)){\n        do_parametric_filter <- FALSE\n    } else {\n        do_parametric_filter <- TRUE\n    }\n\n    # get grid size and define kerenel\n    nvec <- dim(observed)\n    n <- prod(nvec)\n    kern <- sqexp_kern(kern_parm, nvec)\n\n    # impute with mean\n    y0 <- y\n    y0[!observed] <- mean(y, na.rm = TRUE)\n\n    # define likelihood function (written for AR1 filter)\n    likfun <- function(x){\n        expitx <- expit(x)/4\n        return(-whittle_lik(pgram,expitx,par_spec_fun))\n    }\n\n    # set an initial value for optimization\n    parm <- 1/8\n    logitpar <- logit(parm*4)\n\n    # loop over number of iterations\n    specs <- array(NA,c(nvec,n_iter))\n\n    for(k in 1:n_iter){\n        print(k)\n        # periodogram\n        pgram <- 1/n*abs( fft(y0) )^2\n\n        # do the optimization\n        if(do_parametric_filter){\n            res <- optim(logitpar,likfun,method=\"Brent\",lower=-6,upper=6)\n            logitpar <- res$par         # update logit parameter\n            parm <- expit(logitpar)/4   # update parameter\n\n            # parametric approximation\n            param_spec <- par_spec_fun(parm,nvec)\n        } else {\n            param_spec <- array(1,nvec)\n        }\n        #cat(paste(\"parameter\",round(parm,4),\"\\n\"))\n\n        # smooth ratio of periodogram to parametric approximation\n        sm_pgram <- smooth_pgram(pgram/param_spec,kern)\n        # estimate is product of smoothed ratio and parametric spec\n        specs[,,k] <- sm_pgram*param_spec\n\n        # do a conditional simulation with the new spectrum\n        avg_indices <- (max(1,k-n_avg+1)):k\n        avg_spec <- apply( specs[,,avg_indices], c(1,2), mean)\n        #y0 <- condsim_spec(y0,avg_spec,observed,silent = TRUE)\n        y0 <- condsim_spec(y0,specs[,,k],observed, silent = FALSE, maxit = 500, precondmethod = precondmethod, ...)\n    }\n\n    var_asymptotic <- sum(kern^2)*avg_spec^2\n\n    spec_intraclass <- array(NA,c(nvec,n_intraclass))\n\n    condsims <- array( NA, c(nvec,n_intraclass) )\n    for(k in 1:n_intraclass){\n\n        y0 <- condsim_spec(y0,avg_spec,observed,silent=TRUE, maxit = 500, precondmethod = precondmethod, ...)\n        condsims[,,k] <- y0\n        pgram <- 1/n*abs( fft(y0) )^2\n\n        # do the optimization\n        do_optimization <- FALSE\n        if(do_optimization){\n            if(do_parametric_filter){\n                res <- optim(logitpar,likfun,method=\"Brent\",lower=-6,upper=6)\n                logitpar <- res$par         # update logit parameter\n                parm <- expit(logitpar)/4   # update parameter\n\n                # parametric approximation\n                param_spec <- par_spec_fun(parm,nvec)\n            } else {\n                param_spec <- array(1,nvec)\n            }\n        }\n\n        # smooth ratio of periodogram to parametric approximation\n        sm_pgram <- smooth_pgram(pgram/param_spec,kern)\n        # estimate is product of smoothed ratio and parametric spec\n        spec_intraclass[,,k] <- sm_pgram*param_spec\n    }\n\n    var_intraclass <- apply(spec_intraclass, c(1,2), var)\n\n\n    return(list(estimate = avg_spec, var_asymptotic = var_asymptotic,\n                var_intraclass = var_intraclass,\n                condsim = condsims))\n\n}\n\n",
    "created" : 1507680101093.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "757115088",
    "id" : "F79EA898",
    "lastKnownWriteTime" : 1507844218,
    "last_content_update" : 1507844218,
    "path" : "~/Dropbox/research/npspecden/code/npspec/R/iterative_estimation.R",
    "project_path" : "R/iterative_estimation.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}