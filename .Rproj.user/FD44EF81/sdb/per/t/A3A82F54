{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n#include <math.h>\n#include <iostream>\n\n\nusing namespace std;\nusing namespace Rcpp;\n\n\ndouble covfun(double d, double *cparms){\n\n    // has special cases for 1/2 and 3/2\n    if( d == 0.0 ){\n        d = cparms[0];\n    } else {\n        if( cparms[2] == 0.5 ){\n            d = cparms[0]*exp(-d/cparms[1])*cparms[3];\n        } else if( cparms[2] == 1.5 ){\n            d = cparms[0]*(1+d/cparms[1])*exp(-d/cparms[1])*cparms[3];\n        } else {\n            double normcon = cparms[0]/(pow(2.0,cparms[2]-1)*Rf_gammafn(cparms[2]));\n            d = normcon*pow( d/cparms[1], cparms[2] )*\n                Rf_bessel_k(d/cparms[1],cparms[2],1.0);\n        }\n    }\n    return d;\n}\n\n// [[Rcpp::export]]\nNumericVector OrderedCompLik(NumericVector covparms, NumericVector y,\n                             NumericMatrix locs, IntegerMatrix NNarray) {\n\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n    int k;\n    int el;\n    double cparms[4] = {covparms[0], covparms[1], covparms[2], covparms[3]};\n\n    NumericVector ll(1);\n    int n = y.length();\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    double d;\n    double ysub[m];\n    double locsub[m][2];\n\n    double Li[m][m];\n\n    double g[m];\n    double sig[m];\n\n\n\n    for(i=m; i<n+1; i++){\n\n        // first, fill in ysub and locsub in reverse order\n        for(j=m-1; j>=0; j--){\n            locsub[m-1-j][0] = locs( NNarray(i-1,j)-1, 0 );\n            locsub[m-1-j][1] = locs( NNarray(i-1,j)-1, 1 );\n            ysub[m-1-j] = y[ NNarray(i-1,j)-1 ];\n        }\n\n\n        for(k=0;k<m;k++){ for(j=0;j<m;j++){ Li[k][j] = 0.0; }}\n\n        Li[1-1][1-1] = pow( covfun(0, cparms), -0.5 );\n\n        for(j=2; j<m+1; j++){  // j = row of Li\n\n            // initialize g\n            for(k=1; k<m+1; k++){\n                g[k-1] = 0.0;\n            }\n\n            // get first j-1 entries of jth row of L (not Linverse!)\n            for(k=1; k<j; k++){\n                d = pow( pow(locsub[k-1][0] - locsub[j-1][0],2) +\n                          pow(locsub[k-1][1] - locsub[j-1][1],2), 0.5 );\n                sig[k-1] = covfun(d,cparms);\n                g[k-1] = 0.0;\n                for(el=1; el<k+1; el++){\n                    g[k-1] += Li[k-1][el-1]*sig[el-1];\n                }\n            }\n\n            // get diagonal entry\n            d = 0.0;\n            for( k=1;k<j;k++ ){ d += g[k-1]*g[k-1]; }\n            Li[j-1][j-1] = pow( covfun(0,cparms) - d, -0.5 );\n\n            // now get first j-1 entries jth row of Linverse\n            for(k=1; k<j; k++){\n                for(el=1; el<j+1; el++){\n                    Li[j-1][k-1] += g[el-1]*Li[el-1][k-1];\n                }\n                Li[j-1][k-1] = -Li[j-1][k-1]*Li[j-1][j-1];\n            }\n\n        }\n        d = 0.0;\n        if(i==m){\n            for(k=1; k<m+1; k++){\n                d = 0.0;\n                for(el=1; el<k+1; el++){\n                    d += Li[k-1][el-1]*ysub[el-1];\n                }\n                ll(0) += -d*d/2 + log( Li[k-1][k-1] );\n            }\n        } else {\n            d = 0.0;\n            for(k=1;k<m+1;k++){\n                d += Li[m-1][k-1]*ysub[k-1];\n                //printf(\"%6.3f \\n\",d);\n            }\n            ll(0) += -d*d/2 + log( Li[m-1][m-1] );\n        }\n    }\n    ll(0) += -n*log(2*M_PI)/2;\n\n    return ll;\n}\n",
    "created" : 1507827682314.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3971224009",
    "id" : "A3A82F54",
    "lastKnownWriteTime" : 1497978596,
    "last_content_update" : 1497978596,
    "path" : "~/Dropbox/research/aldodevel/src/OrderedCompLik.cpp",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}