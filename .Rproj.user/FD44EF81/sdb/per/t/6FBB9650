{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n#include <math.h>\n#include <iostream>\n\n\nusing namespace std;\nusing namespace Rcpp;\n\n\n// this does the transformation L^{-1}y\n// [[Rcpp::export]]\nNumericVector LinvMult(NumericMatrix covarray, NumericVector y,\n                       NumericMatrix locs, IntegerMatrix NNarray) {\n\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n    int k;\n    int el;\n    //double cparms[4] = {covparms[0], covparms[1], covparms[2], covparms[3]};\n\n    int n = y.length();\n    int dim = locs.ncol();\n    NumericVector z(n);\n    int nvec[dim];\n    nvec[0] = covarray.nrow();\n    if( dim > 1 ) nvec[1] = covarray.ncol();\n    // dim > 2 not supported yet.\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    int h[dim];\n    double d;\n    double ysub[m];\n    double locsub[m][3];\n\n    double Li[m][m];\n\n    double g[m];\n    double sig[m];\n\n\n    // should really do i=m separately. Right now, I need to make\n    // sure that the (m+1)th row of NNarray is\n    // m+1,m,m-1,...,1\n    for(i=m; i<n+1; i++){\n\n        // first, fill in ysub and locsub in reverse order\n        for(j=m-1; j>=0; j--){\n            locsub[m-1-j][0] = locs( NNarray(i-1,j)-1, 0 );\n            locsub[m-1-j][1] = locs( NNarray(i-1,j)-1, 1 );\n            if( dim == 3 ) locsub[m-1-j][2] = locs( NNarray(i-1,j)-1, 2 );\n            ysub[m-1-j] = y[ NNarray(i-1,j)-1 ];\n        }\n\n        // initialize Li\n        for(k=0;k<m;k++){ for(j=0;j<m;j++){ Li[k][j] = 0.0; }}\n\n        // first row has just a single nonzero entry\n        Li[1-1][1-1] = pow( covarray(0,0), -0.5 );\n\n        for(j=2; j<m+1; j++){  // j = row of Li\n\n            // initialize g\n            for(k=1; k<m+1; k++){\n                g[k-1] = 0.0;\n            }\n\n            // get first j-1 entries of jth row of L (not Linverse!)\n            for(k=1; k<j; k++){\n\n                for(el=0; el<dim; el++){\n                    h[el] = locsub[k-1][el] - locsub[j-1][el];\n                    if(h[el] < 0) h[el] += nvec[el];\n                }\n                sig[k-1] = covarray( h[0] , h[1] );\n                g[k-1] = 0.0;\n                for(el=1; el<k+1; el++){\n                    g[k-1] += Li[k-1][el-1]*sig[el-1];\n                }\n            }\n\n            // get diagonal entry\n            d = 0.0;\n            for( k=1;k<j;k++ ){ d += g[k-1]*g[k-1]; }\n            Li[j-1][j-1] = pow( covarray(0,0) - d, -0.5 );\n\n            // now get first j-1 entries jth row of Linverse\n            for(k=1; k<j; k++){\n                for(el=1; el<j+1; el++){\n                    Li[j-1][k-1] += g[el-1]*Li[el-1][k-1];\n                }\n                Li[j-1][k-1] = -Li[j-1][k-1]*Li[j-1][j-1];\n            }\n\n        }\n\n        d = 0.0;\n        if(i==m){\n            // fill in first m entries of z\n            for(k=1; k<m+1; k++){\n                d = 0.0;\n                for(el=1; el<k+1; el++){\n                    d += Li[k-1][el-1]*ysub[el-1];\n                }\n                z(NNarray(m-1,m-k)-1) = d;\n            }\n        } else {\n            // fill in ith entry of z\n            d = 0.0;\n            for(k=1;k<m+1;k++){\n                d += Li[m-1][k-1]*ysub[k-1];\n            }\n            z(i-1) = d;\n        }\n    }\n\n    return z;\n}\n\n\n\n\n\n\n\n\n\n// [[Rcpp::export]]\nNumericVector LinvTransMult(NumericMatrix covarray, NumericVector z,\n                       NumericMatrix locs, IntegerMatrix NNarray) {\n\n    // here, z is the result of Linv * z\n    // return x = Linv^T z\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n    int k;\n    int el;\n    //double cparms[4] = {covparms[0], covparms[1], covparms[2], covparms[3]};\n\n    int n = z.length();\n    int dim = locs.ncol();\n    NumericVector x(n);\n    for(j=0;j<n;j++){ x[j] = 0.0; }\n    int nvec[dim];\n    nvec[0] = covarray.nrow();\n    if( dim > 1 ) nvec[1] = covarray.ncol();\n    // dim > 2 not supported yet.\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    int h[dim];\n    double d;\n    int isub[m];\n    double locsub[m][3];\n\n    double Li[m][m];\n\n    double g[m];\n    double sig[m];\n\n\n    // should really do i=m separately. Right now, I need to make\n    // sure that the (m+1)th row of NNarray is\n    // m+1,m,m-1,...,1\n    for(i=m; i<n+1; i++){\n\n        // first, fill in ysub and locsub in reverse order\n        for(j=m-1; j>=0; j--){\n            locsub[m-1-j][0] = locs( NNarray(i-1,j)-1, 0 );\n            locsub[m-1-j][1] = locs( NNarray(i-1,j)-1, 1 );\n            if( dim == 3 ) locsub[m-1-j][2] = locs( NNarray(i-1,j)-1, 2 );\n            isub[m-1-j] = NNarray(i-1,j)-1;\n        }\n\n        // initialize Li\n        for(k=0;k<m;k++){ for(j=0;j<m;j++){ Li[k][j] = 0.0; }}\n\n        // first row has just a single nonzero entry\n        Li[1-1][1-1] = pow( covarray(0,0), -0.5 );\n\n        for(j=2; j<m+1; j++){  // j = row of Li\n\n            // initialize g\n            for(k=1; k<m+1; k++){\n                g[k-1] = 0.0;\n            }\n\n            // get first j-1 entries of jth row of L (not Linverse!)\n            for(k=1; k<j; k++){\n\n                for(el=0; el<dim; el++){\n                    h[el] = locsub[k-1][el] - locsub[j-1][el];\n                    if(h[el] < 0) h[el] += nvec[el];\n                }\n                sig[k-1] = covarray( h[0] , h[1] );\n                g[k-1] = 0.0;\n                for(el=1; el<k+1; el++){\n                    g[k-1] += Li[k-1][el-1]*sig[el-1];\n                }\n            }\n\n            // get diagonal entry\n            d = 0.0;\n            for( k=1;k<j;k++ ){ d += g[k-1]*g[k-1]; }\n            Li[j-1][j-1] = pow( covarray(0,0) - d, -0.5 );\n\n            // now get first j-1 entries jth row of Linverse\n            for(k=1; k<j; k++){\n                for(el=1; el<j+1; el++){\n                    Li[j-1][k-1] += g[el-1]*Li[el-1][k-1];\n                }\n                Li[j-1][k-1] = -Li[j-1][k-1]*Li[j-1][j-1];\n            }\n\n        }\n\n        d = 0.0;\n        if(i==m){\n            // fill in first m entries of z\n            for(k=1; k<m+1; k++){\n                d = 0.0;\n                for(el=1; el<k+1; el++){\n                    x[isub[el-1]] += Li[k-1][el-1]*z[k-1];\n                }\n            }\n        } else {\n            // fill in ith entry of z\n            for(k=1;k<m+1;k++){\n                x[isub[k-1]] += Li[m-1][k-1]*z[i-1];\n            }\n        }\n    }\n    return x;\n}\n\n// [[Rcpp::export]]\nNumericVector vecchiaPrecond(NumericMatrix covarray, NumericVector y,\n                              NumericMatrix locs, IntegerMatrix NNarray){\n\n    int n = y.length();\n    NumericVector x(n);\n\n    x = LinvMult(covarray, y, locs, NNarray);\n    x = LinvTransMult(covarray, x, locs, NNarray);\n\n    return x;\n}\n\n\n\n// this does the transformation L^{-1}y\n// [[Rcpp::export]]\nNumericMatrix getLinvEntries(NumericMatrix covarray,\n                       NumericMatrix locs, IntegerMatrix NNarray) {\n\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n    int k;\n    int el;\n    //double cparms[4] = {covparms[0], covparms[1], covparms[2], covparms[3]};\n\n    int n = locs.nrow();\n    int dim = locs.ncol();\n    int nvec[dim];\n    nvec[0] = covarray.nrow();\n    if( dim > 1 ) nvec[1] = covarray.ncol();\n    // dim > 2 not supported yet.\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    int h[dim];\n    double d;\n    double locsub[m][3];\n\n    double Li[m][m];\n\n    double g[m];\n    double sig[m];\n\n    NumericMatrix LinvEntries(n,m);\n\n\n    // should really do i=m separately. Right now, I need to make\n    // sure that the (m+1)th row of NNarray is\n    // m+1,m,m-1,...,1\n    for(i=m; i<n+1; i++){\n\n        // first, fill in ysub and locsub in reverse order\n        for(j=m-1; j>=0; j--){\n            locsub[m-1-j][0] = locs( NNarray(i-1,j)-1, 0 );\n            locsub[m-1-j][1] = locs( NNarray(i-1,j)-1, 1 );\n            if( dim == 3 ) locsub[m-1-j][2] = locs( NNarray(i-1,j)-1, 2 );\n        }\n\n        // initialize Li\n        for(k=0;k<m;k++){ for(j=0;j<m;j++){ Li[k][j] = 0.0; }}\n\n        // first row has just a single nonzero entry\n        Li[1-1][1-1] = pow( covarray(0,0), -0.5 );\n\n        for(j=2; j<m+1; j++){  // j = row of Li\n\n            // initialize g\n            for(k=1; k<m+1; k++){\n                g[k-1] = 0.0;\n            }\n\n            // get first j-1 entries of jth row of L (not Linverse!)\n            for(k=1; k<j; k++){\n\n                for(el=0; el<dim; el++){\n                    h[el] = locsub[k-1][el] - locsub[j-1][el];\n                    if(h[el] < 0) h[el] += nvec[el];\n                }\n                sig[k-1] = covarray( h[0] , h[1] );\n                g[k-1] = 0.0;\n                for(el=1; el<k+1; el++){\n                    g[k-1] += Li[k-1][el-1]*sig[el-1];\n                }\n            }\n\n            // get diagonal entry\n            d = 0.0;\n            for( k=1;k<j;k++ ){ d += g[k-1]*g[k-1]; }\n            Li[j-1][j-1] = pow( covarray(0,0) - d, -0.5 );\n\n            // now get first j-1 entries jth row of Linverse\n            for(k=1; k<j; k++){\n                for(el=1; el<j+1; el++){\n                    Li[j-1][k-1] += g[el-1]*Li[el-1][k-1];\n                }\n                Li[j-1][k-1] = -Li[j-1][k-1]*Li[j-1][j-1];\n            }\n\n        }\n\n        d = 0.0;\n        if(i==m){\n            // fill in first m rows of LinvEntries\n            for(k=1; k<m+1; k++){\n                for(el=1; el<k+1; el++){\n                    LinvEntries(k-1,el-1) = Li[k-1][k-el];\n                }\n            }\n        } else {\n            // fill in ith row of LinvEntries\n            d = 0.0;\n            for(k=1;k<m+1;k++){\n                LinvEntries(i-1,k-1) = Li[m-1][m-k];\n            }\n        }\n    }\n\n    return LinvEntries;\n}\n\n\n\n\n// [[Rcpp::export]]\nNumericVector LinvTransMultFromEntries(NumericMatrix LinvEntries, NumericVector z,\n                            IntegerMatrix NNarray) {\n\n    // here, z is the result of Linv * z\n    // return x = Linv^T z\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n\n    int n = z.length();\n    NumericVector x(n);\n    for(j=0;j<n;j++){ x[j] = 0.0; }\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    // is it this simple (first m rows)\n    for(i=1; i<m; i++){\n        for(j=1; j<i+1; j++){\n            x( NNarray(i-1,j-1)-1 ) += z(i-1)*LinvEntries(i-1,j-1);\n        }\n    }\n\n    // all rows after m\n    for(i=m; i<n+1; i++){\n        for(j=1; j<m+1; j++){\n            x( NNarray(i-1,j-1)-1 ) += z(i-1)*LinvEntries(i-1,j-1);\n        }\n    }\n\n    return x;\n}\n\n// [[Rcpp::export]]\nNumericVector LinvMultFromEntries(NumericMatrix LinvEntries, NumericVector z,\n                                       IntegerMatrix NNarray) {\n\n    // here, z is the result of Linv * z\n    // return x = Linv^T z\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n\n    int n = z.length();\n    NumericVector x(n);\n    for(j=0;j<n;j++){ x[j] = 0.0; }\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    // is it this simple (first m rows)\n    for(i=1; i<m; i++){\n        for(j=1; j<i+1; j++){\n            x( i - 1 ) += z( NNarray(i-1,j-1) - 1 )*LinvEntries(i-1,j-1);\n        }\n    }\n\n    // all rows after m\n    for(i=m; i<n+1; i++){\n        for(j=1; j<m+1; j++){\n            x( i-1 ) += z( NNarray(i-1,j-1) - 1 )*LinvEntries(i-1,j-1);\n        }\n    }\n\n    return x;\n}\n\n\n\n\n// [[Rcpp::export]]\nNumericVector vecchiaPrecondFromEntries(NumericMatrix LinvEntries, NumericVector y,\n                              IntegerMatrix NNarray){\n\n    int n = y.length();\n    NumericVector x(n);\n\n    x = LinvMultFromEntries(LinvEntries, y, NNarray);\n    x = LinvTransMultFromEntries(LinvEntries, x, NNarray);\n\n    return x;\n}\n\n\n\n\n// [[Rcpp::export]]\nNumericVector vecchiaLik(NumericMatrix covarray, NumericVector y,\n                       NumericMatrix locs, IntegerMatrix NNarray) {\n\n    //const double PI = 3.141592653589793238463;\n    int i;\n    int j;\n    int k;\n    int el;\n    //double cparms[4] = {covparms[0], covparms[1], covparms[2], covparms[3]};\n\n    int n = y.length();\n    int dim = locs.ncol();\n    NumericVector ll(1);\n    int nvec[dim];\n    nvec[0] = covarray.nrow();\n    if( dim > 1 ) nvec[1] = covarray.ncol();\n    // dim > 2 not supported yet.\n\n    // number of neighbors + 1\n    int m = NNarray.ncol();\n\n    int h[dim];\n    double d;\n    double ysub[m];\n    double locsub[m][3];\n\n    double Li[m][m];\n\n    double g[m];\n    double sig[m];\n\n\n    // should really do i=m separately. Right now, I need to make\n    // sure that the (m+1)th row of NNarray is\n    // m+1,m,m-1,...,1\n    for(i=m; i<n+1; i++){\n\n        // first, fill in ysub and locsub in reverse order\n        for(j=m-1; j>=0; j--){\n            locsub[m-1-j][0] = locs( NNarray(i-1,j)-1, 0 );\n            locsub[m-1-j][1] = locs( NNarray(i-1,j)-1, 1 );\n            if( dim == 3 ) locsub[m-1-j][2] = locs( NNarray(i-1,j)-1, 2 );\n            ysub[m-1-j] = y[ NNarray(i-1,j)-1 ];\n        }\n\n        // initialize Li\n        for(k=0;k<m;k++){ for(j=0;j<m;j++){ Li[k][j] = 0.0; }}\n\n        // first row has just a single nonzero entry\n        Li[1-1][1-1] = pow( covarray(0,0), -0.5 );\n\n        for(j=2; j<m+1; j++){  // j = row of Li\n\n            // initialize g\n            for(k=1; k<m+1; k++){\n                g[k-1] = 0.0;\n            }\n\n            // get first j-1 entries of jth row of L (not Linverse!)\n            for(k=1; k<j; k++){\n\n                for(el=0; el<dim; el++){\n                    h[el] = locsub[k-1][el] - locsub[j-1][el];\n                    if(h[el] < 0) h[el] += nvec[el];\n                }\n                sig[k-1] = covarray( h[0] , h[1] );\n                g[k-1] = 0.0;\n                for(el=1; el<k+1; el++){\n                    g[k-1] += Li[k-1][el-1]*sig[el-1];\n                }\n            }\n\n            // get diagonal entry\n            d = 0.0;\n            for( k=1;k<j;k++ ){ d += g[k-1]*g[k-1]; }\n            Li[j-1][j-1] = pow( covarray(0,0) - d, -0.5 );\n\n            // now get first j-1 entries jth row of Linverse\n            for(k=1; k<j; k++){\n                for(el=1; el<j+1; el++){\n                    Li[j-1][k-1] += g[el-1]*Li[el-1][k-1];\n                }\n                Li[j-1][k-1] = -Li[j-1][k-1]*Li[j-1][j-1];\n            }\n\n        }\n\n        d = 0.0;\n        if(i==m){\n            // fill in first m entries of z\n            for(k=1; k<m+1; k++){\n                d = 0.0;\n                for(el=1; el<k+1; el++){\n                    d += Li[k-1][el-1]*ysub[el-1];\n                }\n                ll(0) += -d*d/2 + log( Li[k-1][k-1] );\n            }\n        } else {\n            // fill in ith entry of z\n            d = 0.0;\n            for(k=1;k<m+1;k++){\n                d += Li[m-1][k-1]*ysub[k-1];\n            }\n            ll(0) += -d*d/2 + log( Li[m-1][m-1] );\n        }\n    }\n\n    return ll;\n}\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1507674589606.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "241|73|250|0|\n",
    "hash" : "2232642486",
    "id" : "6FBB9650",
    "lastKnownWriteTime" : 1507827857,
    "last_content_update" : 1507827857966,
    "path" : "~/Dropbox/research/npspecden/code/npspec/src/vecchia_precond.cpp",
    "project_path" : "src/vecchia_precond.cpp",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}